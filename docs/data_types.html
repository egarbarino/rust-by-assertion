<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>data_types</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#data-types">Data Types</a>
<ul>
<li><a href="#scalar-types">Scalar Types</a>
<ul>
<li><a href="#booleans">Booleans</a></li>
<li><a href="#integers">Integers</a></li>
<li><a href="#floats">Floats</a></li>
<li><a href="#characters">Characters</a></li>
</ul></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">Slices</a>
<ul>
<li><a href="#array-slices">Array slices</a></li>
<li><a href="#string-slices">String slices</a></li>
</ul></li>
</ul></li>
<li><a href="#variables">Variables</a>
<ul>
<li><a href="#constants">Constants</a></li>
<li><a href="#immutable-and-mutable-variables">Immutable and Mutable
Variables</a></li>
<li><a href="#static-variables">Static variables</a></li>
<li><a href="#variable-scope">Variable Scope</a></li>
</ul></li>
</ul>
</nav>
<h1 id="data-types">Data Types</h1>
<h2 id="scalar-types">Scalar Types</h2>
<p>A scalar type represents a single value.</p>
<h3 id="booleans">Booleans</h3>
<p>Booleans use the <code>true</code> and <code>false</code> literals
and can be reversed using <code>!</code>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_booleans() <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="cn">true</span><span class="op">,</span> <span class="op">!</span><span class="cn">false</span>)<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="cn">false</span><span class="op">,</span> <span class="op">!</span><span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t <span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="integers">Integers</h3>
<p>If integers are unsigned, their type is prefixed with <code>u</code>,
otherwise, they are prefixed with <code>i</code> (as in ‘regular’
integer). After the <code>u</code> or <code>i</code> prefix, their size
in bits is indicated, ranging from 8 to 128.</p>
<p>The <code>usize</code> type represents the architecture-dependant
integer type that is valid for addressing purposes. In contemporary
computers, this is equivalent to <code>u64</code>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_unsigned_integers() <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u8</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u8</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u16</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u16</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">65535</span>)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">4294967295</span>)<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">18446744073709551615</span>)<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">usize</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">usize</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">18446744073709551615</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u128</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u128</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">340282366920938463463374607431768211455</span>)<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_signed_integers() <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i8</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">128</span>)<span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i8</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">127</span>)<span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i16</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">32768</span>)<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i16</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">32767</span>)<span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">2147483648</span>)<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">2147483647</span>)<span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">9223372036854775808</span>)<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">9223372036854775807</span>)<span class="op">;</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">isize</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">9223372036854775808</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">isize</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">9223372036854775807</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i128</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">170141183460469231731687303715884105728</span>)<span class="op">;</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i128</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">170141183460469231731687303715884105727</span>)<span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Integer literals may be expressed as follows:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_integer_literals() <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">2500</span><span class="op">,</span> <span class="dv">2_500</span>)<span class="op">;</span>      <span class="co">/* Thousands separeted by _ */</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">255</span><span class="op">,</span> <span class="dv">0xff</span>)<span class="op">;</span>        <span class="co">/* Hexadecimal              */</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">255</span><span class="op">,</span> <span class="dv">0b11111111</span>)<span class="op">;</span>  <span class="co">/* Binary                   */</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">65</span><span class="op">,</span> <span class="ch">b&#39;A&#39;</span>)<span class="op">;</span>         <span class="co">/* Character code           */</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Regular operators are implemented as in most languages, except for
power.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_integer_operators()<span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">3</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">6</span> <span class="op">/</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">5</span> <span class="op">%</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span>             <span class="co">/* modulo */</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>((<span class="dv">2</span> <span class="kw">as</span> <span class="dt">u32</span>)<span class="op">.</span>pow(<span class="dv">3</span>)<span class="op">,</span> <span class="dv">8</span>)<span class="op">;</span> <span class="co">/* power  */</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike other languages, Rust treats the exceeding of an integer’s
size as an overflow. If a wrapping behaviour is desired, the
<code>wrapping_add</code> method could be used, instead.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_integer_wrapping() <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> a <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">255</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* a += 1; panics */</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> a<span class="op">.</span>wrapping_add(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="floats">Floats</h3>
<p>Rust implements floats using the IEEE 754 standard.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_floats() <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">3.4028235e38</span>)<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">3.4028235e38</span>)<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">1.7976931348623157e308</span>)<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">1.7976931348623157e308</span>)<span class="op">;</span>   </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Operators behave like in most conventional languages, except for
power which requires the <code>powf</code> function.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_float_operators()<span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">0.7</span> <span class="op">+</span> <span class="dv">0.3</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">1.5</span> <span class="op">-</span> <span class="dv">0.5</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">2.5</span> <span class="op">*</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">7.5</span>)<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">6.0</span> <span class="op">/</span> <span class="dv">2.5</span><span class="op">,</span> <span class="dv">2.4</span>)<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>((<span class="dv">1.5</span> <span class="kw">as</span> <span class="dt">f32</span>)<span class="op">.</span>powf(<span class="dv">2.0</span>)<span class="op">,</span> <span class="dv">2.25</span>)<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="characters">Characters</h3>
<p>Characters in Rust aren’t bytes. They use a 32-bit integer-like type
which can encode unicode characters.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_characters() <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c1 <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c2<span class="op">:</span> <span class="dt">char</span> <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(c1<span class="op">,</span> c2)<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(c1 <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">65</span>)<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>)<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MIN</span> <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="ch">&#39;</span><span class="sc">\u{10ffff}</span><span class="ch">&#39;</span>)<span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MAX</span> <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">1114111</span>)<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="ch">&#39;😊&#39;</span> <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">0x1F60A</span>)<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="tuples">Tuples</h2>
<p>Tuples have a fixed length. Each component may be of a different
type. Tuples are both constructed and deconstructed in Rust using the
<code>(c1, c2, ...)</code> notation like in many other languages.</p>
<p>Components may be extracted individually using the
<code>tuple.index</code> notation, starting from zero.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_tuples() <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Tuple construction with explicit type information */</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t <span class="op">:</span> (<span class="dt">u8</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">bool</span>) <span class="op">=</span> (<span class="dv">255</span><span class="op">,</span><span class="ch">&#39;A&#39;</span><span class="op">,</span><span class="cn">true</span>)<span class="op">;</span> </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Query components by coordinate index */</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">.</span><span class="dv">0</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">.</span><span class="dv">1</span><span class="op">,</span> <span class="ch">&#39;A&#39;</span>)<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">.</span><span class="dv">2</span><span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Deconstruction: assign components to variables */</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (x<span class="op">,</span>y<span class="op">,</span>z) <span class="op">=</span> t<span class="op">;</span> </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(y<span class="op">,</span> <span class="ch">&#39;A&#39;</span>)<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(z<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Deconstruction: using wild card _ to ignore components */</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (_<span class="op">,</span>_<span class="op">,</span>last) <span class="op">=</span> t<span class="op">;</span> </span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(last<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Construction of Unit tuple: zero components */</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> unit <span class="op">=</span> ()<span class="op">;</span> </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(unit<span class="op">,</span> ())<span class="op">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="arrays">Arrays</h2>
<p>Arrays have a fixed length and their elements have the same type as
in most statically-typed languages. The length is checked using the
<code>len</code> method, while elements are obtained using the standard
<code>array[element_index]</code> notation.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_arrays() <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Type information is optional */</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a_typed <span class="op">:</span> [<span class="dt">u8</span><span class="op">;</span> <span class="dv">3</span>] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">,</span> a_typed)<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">.</span>len()<span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Obtaining elements by index */</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a[<span class="dv">0</span>]<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a[<span class="dv">1</span>]<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a[<span class="dv">2</span>]<span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* assert_eq!(a[3], 3); won&#39;t compile */</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Filling an array with repeated values */</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a_repeat <span class="op">=</span> [<span class="dv">0</span><span class="op">;</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a_repeat<span class="op">,</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="slices">Slices</h2>
<p>A slice in Rust, similarly to Go, acts as a ‘view’ upon an array.
Such a view consists of a start and end indices. A slice, as the name
suggests, allow manipulating subsets of an array without the need of
having to allocate a new one.</p>
<p>Assuming we have an array in hand, obtaining a slice involves
addressing it by reference and specifying the desired range:
<code>&amp;array[start_index..end_index+1]</code>.</p>
<h3 id="array-slices">Array slices</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_slice_regular_arrays() <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Index            0 1 2 3 4 */</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">:</span> [<span class="dt">u8</span> <span class="op">;</span> <span class="dv">5</span>] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> len <span class="op">=</span> a<span class="op">.</span>len()<span class="op">;</span> </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(len<span class="op">,</span><span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span>len]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span> <span class="co">/* From 0 to the 5-1 (4) */</span>  </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>    <span class="co">/* From 0 to the end of the array */</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="op">..</span>len]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>  <span class="co">/* From the start to 5-1 (4) */</span> </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..=</span><span class="dv">4</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>  <span class="co">/* From 0 to 4 */</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="op">..</span><span class="dv">3</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])<span class="op">;</span>        <span class="co">/* From the start to 3-1 (2) */</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span><span class="dv">3</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])<span class="op">;</span>       <span class="co">/* From 0 to 3-1 (2) */</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..</span>]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>          <span class="co">/* From 3 to the end of the array */</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..</span>len]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>       <span class="co">/* From 3 to 5-1 (4) */</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..</span><span class="dv">5</span>]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>         <span class="co">/* From 3 to 5-1 (4) */</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..=</span><span class="dv">4</span>]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>        <span class="co">/* From 3 to 4 */</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(return_array_slice(<span class="op">&amp;</span>a)<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the input is a fixed-size array but the output is a
size-independent slice</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> return_array_slice(a <span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span> <span class="op">;</span> <span class="dv">5</span>]) <span class="op">-&gt;</span> <span class="op">&amp;</span>[<span class="dt">u8</span>] <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span><span class="dv">3</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="string-slices">String slices</h3>
<p>There isn’t much special about string aliases, except that the string
slice type is <code>&amp;str</code> rather than
<code>&amp;String</code></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_slice_string() <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Index              0123456789 */</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*                              10 */</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> len <span class="op">=</span> s<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(len<span class="op">,</span> <span class="dv">11</span>)<span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span>len]<span class="op">,</span><span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span>]<span class="op">,</span><span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="op">..</span>len]<span class="op">,</span><span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="op">..</span><span class="dv">5</span>]<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>]<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..=</span><span class="dv">4</span>]<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..</span>]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..</span>len]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..</span><span class="dv">11</span>]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..=</span><span class="dv">10</span>]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(return_string_slice(<span class="op">&amp;</span>s)<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the slice for a string is <code>&amp;str</code> rather than
<code>&amp;String</code></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> return_string_slice(s <span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="variables">Variables</h1>
<h2 id="constants">Constants</h2>
<p>Constants are inlined whenever they are evaluated rather than being
stored in a single memory location.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> MILLENNIUM_BUG <span class="op">:</span> <span class="dt">u16</span> <span class="op">=</span> <span class="dv">2000</span><span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_constants() <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(MILLENNIUM_BUG<span class="op">,</span> <span class="dv">2000</span>)<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="immutable-and-mutable-variables">Immutable and Mutable
Variables</h2>
<p>Variables are declared using the <code>let</code> keyword and are
immutable by default unless the <code>mut</code> modifier is
included.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_variables() <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _a <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">9</span><span class="op">;</span>       <span class="co">/* Immutable by default */</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* _a += 1; won&#39;t compile, variable is immutable */</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> b <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">9</span><span class="op">;</span>    <span class="co">/* Made mutable by adding &#39;mut&#39; */</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    b <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(b<span class="op">,</span> <span class="dv">10</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="static-variables">Static variables</h2>
<p>Static variables are stored in a fixed memory location and referenced
accordingly whenever evaluated.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> BEST_COMMODORE_COMPUTER <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">64</span><span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Unsafe; avoid this if possible */</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> <span class="kw">mut</span> INITIAL_TEMPERATURE <span class="op">:</span> <span class="dt">i8</span> <span class="op">=</span> <span class="op">-</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_static_variables() <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(BEST_COMMODORE_COMPUTER<span class="op">,</span> <span class="dv">64</span>)<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Use Mutex mechanism or similar to be safe */</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        INITIAL_TEMPERATURE <span class="op">+=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(INITIAL_TEMPERATURE<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="variable-scope">Variable Scope</h2>
<p>As in most C-like languages, curly braces introduce a new scope.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_variable_scope_1() <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* This is a different x */</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* This is the original x */</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike, say, pure functional languages, variable names may be reused
within the same scope. Please note that it is the variable name that is
being reused, rather than the type it can accommodate.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_variable_scope_2() <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> asterisks <span class="op">=</span> [<span class="ch">&#39;*&#39;</span><span class="op">;</span><span class="dv">5</span>]<span class="op">;</span>         <span class="co">/* Here asterisks is an array */</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> asterisks <span class="op">=</span> asterisks<span class="op">.</span>len()<span class="op">;</span> <span class="co">/* Here asterisks is an integer */</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(asterisks<span class="op">,</span><span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</body>
</html>
