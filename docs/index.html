<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ernesto Garbarino" />
  <meta name="dcterms.date" content="2025-02-18" />
  <title>Rust by Assertion</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Rust by Assertion</h1>
<p class="author">Ernesto Garbarino</p>
<p class="date">2025-02-18</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#simple-data-types">Simple Data Types</a>
<ul>
<li><a href="#scalar-types">Scalar Types</a>
<ul>
<li><a href="#booleans">Booleans</a></li>
<li><a href="#integers">Integers</a></li>
<li><a href="#floats">Floats</a></li>
<li><a href="#characters">Characters</a></li>
</ul></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">Slices</a>
<ul>
<li><a href="#array-slices">Array slices</a></li>
<li><a href="#string-slices">String slices</a></li>
</ul></li>
</ul></li>
<li><a href="#variables">Variables</a>
<ul>
<li><a href="#constants">Constants</a></li>
<li><a href="#immutable-and-mutable-variables">Immutable and Mutable
Variables</a></li>
<li><a href="#static-variables">Static variables</a></li>
<li><a href="#variable-scope">Variable Scope</a></li>
</ul></li>
<li><a href="#structs">Structs</a>
<ul>
<li><a href="#struct-definition">Struct Definition</a></li>
<li><a href="#regular-struct-construction-and-query">Regular Struct
Construction and Query</a></li>
<li><a href="#name-matching-struct-construction">Name-matching Struct
Construction</a></li>
<li><a href="#updating-mutable-struct">Updating Mutable Struct</a></li>
<li><a href="#updating-immutable-struct">Updating Immutable
Struct</a></li>
<li><a href="#composite-structs">Composite Structs</a></li>
<li><a href="#tuple-struct">Tuple Struct</a></li>
<li><a href="#unit-like-struct">Unit-Like Struct</a></li>
</ul></li>
<li><a href="#control-flow">Control Flow</a>
<ul>
<li><a href="#if-statements">If Statements</a></li>
<li><a href="#if-expressions">If Expressions</a></li>
<li><a href="#infinite-loop-statements">Infinite Loop
Statements</a></li>
<li><a href="#infinite-loop-expressions">Infinite Loop
Expressions</a></li>
<li><a href="#while-loop">While Loop</a></li>
<li><a href="#for-loop">For Loop</a></li>
<li><a href="#for-loop-range">For Loop (Range)</a></li>
<li><a href="#for-loop-over-index">For Loop over Index</a></li>
</ul></li>
</ul>
</nav>
<h1 id="simple-data-types">Simple Data Types</h1>
<h2 id="scalar-types">Scalar Types</h2>
<p>A scalar type represents a single value.</p>
<h3 id="booleans">Booleans</h3>
<p>Booleans use the <code>true</code> and <code>false</code> literals
and can be negated using <code>!</code>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_booleans() <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="cn">true</span><span class="op">,</span> <span class="op">!</span><span class="cn">false</span>)<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="cn">false</span><span class="op">,</span> <span class="op">!</span><span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t <span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="integers">Integers</h3>
<p>If integers are unsigned, their type is prefixed with <code>u</code>,
otherwise, they are prefixed with <code>i</code> (as in â€˜regularâ€™
integer). After the <code>u</code> or <code>i</code> prefix, their size
in bits is indicated, ranging from 8 to 128.</p>
<p>The <code>usize</code> type represents the architecture-dependant
integer type that is valid for addressing purposes. In contemporary
computers, this is equivalent to <code>u64</code>.</p>
<p>Letâ€™s look first at unsigned integersâ€¦</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_unsigned_integers() <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u8</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u8</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u16</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u16</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">65535</span>)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">4294967295</span>)<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">18446744073709551615</span>)<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">usize</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">usize</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">18446744073709551615</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u128</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">u128</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">340282366920938463463374607431768211455</span>)<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>â€¦ and now at signed ones:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_signed_integers() <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i8</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">128</span>)<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i8</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">127</span>)<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i16</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">32768</span>)<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i16</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">32767</span>)<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">2147483648</span>)<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">2147483647</span>)<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">9223372036854775808</span>)<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">9223372036854775807</span>)<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">isize</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">9223372036854775808</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">isize</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">9223372036854775807</span>)<span class="op">;</span> <span class="co">/* Arch dependant */</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i128</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">170141183460469231731687303715884105728</span>)<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">i128</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">170141183460469231731687303715884105727</span>)<span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Integer literals may be expressed as follows:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_integer_literals() <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">2500</span><span class="op">,</span> <span class="dv">2_500</span>)<span class="op">;</span>      <span class="co">/* Thousands separeted by _ */</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">255</span><span class="op">,</span> <span class="dv">0xff</span>)<span class="op">;</span>        <span class="co">/* Hexadecimal              */</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">255</span><span class="op">,</span> <span class="dv">0b11111111</span>)<span class="op">;</span>  <span class="co">/* Binary                   */</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">65</span><span class="op">,</span> <span class="ch">b&#39;A&#39;</span>)<span class="op">;</span>         <span class="co">/* Character code           */</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Regular operators are implemented as in most languages, except for
power which requires the <code>pow()</code> method.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_integer_operators()<span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">3</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">6</span> <span class="op">/</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">5</span> <span class="op">%</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span>             <span class="co">/* modulo */</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>((<span class="dv">2</span> <span class="kw">as</span> <span class="dt">u32</span>)<span class="op">.</span>pow(<span class="dv">3</span>)<span class="op">,</span> <span class="dv">8</span>)<span class="op">;</span> <span class="co">/* power  */</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike other languages, Rust treats the exceeding of an integerâ€™s
size as an overflow. If a wrapping behaviour is desired, the
<code>wrapping_add</code> method could be used, instead.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_integer_wrapping() <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> a <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">255</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* a += 1; panics */</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> a<span class="op">.</span>wrapping_add(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="floats">Floats</h3>
<p>Rust implements floats using the IEEE 754 standard.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_floats() <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">3.4028235e38</span>)<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">3.4028235e38</span>)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="op">-</span><span class="dv">1.7976931348623157e308</span>)<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">f64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="dv">1.7976931348623157e308</span>)<span class="op">;</span>   </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Operators behave like in most conventional languages, except for
power which requires the <code>powf()</code> method.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_float_operators()<span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">0.7</span> <span class="op">+</span> <span class="dv">0.3</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">1.5</span> <span class="op">-</span> <span class="dv">0.5</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">2.5</span> <span class="op">*</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">7.5</span>)<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dv">6.0</span> <span class="op">/</span> <span class="dv">2.5</span><span class="op">,</span> <span class="dv">2.4</span>)<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>((<span class="dv">1.5</span> <span class="kw">as</span> <span class="dt">f32</span>)<span class="op">.</span>powf(<span class="dv">2.0</span>)<span class="op">,</span> <span class="dv">2.25</span>)<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="characters">Characters</h3>
<p>Characters in Rust arenâ€™t bytes. They use a 32-bit integer-like type
which can encode unicode characters.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_characters() <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c1 <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c2<span class="op">:</span> <span class="dt">char</span> <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(c1<span class="op">,</span> c2)<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(c1 <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">65</span>)<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">,</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>)<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MIN</span> <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> <span class="ch">&#39;</span><span class="sc">\u{10ffff}</span><span class="ch">&#39;</span>)<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="dt">char</span><span class="pp">::</span><span class="cn">MAX</span> <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">1114111</span>)<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="ch">&#39;ðŸ˜Š&#39;</span> <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">0x1F60A</span>)<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="tuples">Tuples</h2>
<p>Tuples have a fixed length. Each component may be of a different
type. Tuples are both constructed and deconstructed in Rust using the
<code>(c1, c2, ...)</code> notation like in many other languages.</p>
<p>Components may be extracted individually using the
<code>tuple.index</code> notation, starting from zero.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_tuples() <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Tuple construction with explicit type information */</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t <span class="op">:</span> (<span class="dt">u8</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">bool</span>) <span class="op">=</span> (<span class="dv">255</span><span class="op">,</span><span class="ch">&#39;A&#39;</span><span class="op">,</span><span class="cn">true</span>)<span class="op">;</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Query components by coordinate index */</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">.</span><span class="dv">0</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">.</span><span class="dv">1</span><span class="op">,</span> <span class="ch">&#39;A&#39;</span>)<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(t<span class="op">.</span><span class="dv">2</span><span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Deconstruction: assign components to variables */</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (x<span class="op">,</span>y<span class="op">,</span>z) <span class="op">=</span> t<span class="op">;</span> </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(y<span class="op">,</span> <span class="ch">&#39;A&#39;</span>)<span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(z<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Deconstruction: using wild card _ to ignore components */</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (_<span class="op">,</span>_<span class="op">,</span>last) <span class="op">=</span> t<span class="op">;</span> </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(last<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Construction of Unit tuple: zero components */</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> unit <span class="op">=</span> ()<span class="op">;</span> </span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(unit<span class="op">,</span> ())<span class="op">;</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="arrays">Arrays</h2>
<p>Arrays have a fixed length and their elements have the same type as
in most statically-typed languages. The length is checked using the
<code>len</code> method, while elements are obtained using the standard
<code>array[element_index]</code> notation.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_arrays() <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Type information is optional */</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a_typed <span class="op">:</span> [<span class="dt">u8</span><span class="op">;</span> <span class="dv">3</span>] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">,</span> a_typed)<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">.</span>len()<span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Obtaining elements by index */</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a[<span class="dv">0</span>]<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a[<span class="dv">1</span>]<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a[<span class="dv">2</span>]<span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* assert_eq!(a[3], 3); won&#39;t compile */</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Filling an array with repeated values */</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a_repeat <span class="op">=</span> [<span class="dv">0</span><span class="op">;</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a_repeat<span class="op">,</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="slices">Slices</h2>
<p>A slice in Rust, similarly to Go, acts as a â€˜viewâ€™ upon an array.
Such a view consists of start and end indices. A slice, as the name
suggests, allow manipulating subsets of an array without the need of
having to allocate a new one.</p>
<p>Assuming we have an array in hand, obtaining a slice involves
addressing it by reference and specifying the desired range:
<code>&amp;array[start_index..end_index+1]</code>.</p>
<h3 id="array-slices">Array slices</h3>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_slice_regular_arrays() <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Index            0 1 2 3 4 */</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">:</span> [<span class="dt">u8</span> <span class="op">;</span> <span class="dv">5</span>] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> len <span class="op">=</span> a<span class="op">.</span>len()<span class="op">;</span> </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(len<span class="op">,</span><span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span>len]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span> <span class="co">/* From 0 to the 5-1 (4) */</span>  </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>    <span class="co">/* From 0 to the end of the array */</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="op">..</span>len]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>  <span class="co">/* From the start to 5-1 (4) */</span> </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..=</span><span class="dv">4</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>  <span class="co">/* From 0 to 4 */</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="op">..</span><span class="dv">3</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])<span class="op">;</span>        <span class="co">/* From the start to 3-1 (2) */</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span><span class="dv">3</span>]<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])<span class="op">;</span>       <span class="co">/* From 0 to 3-1 (2) */</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..</span>]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>          <span class="co">/* From 3 to the end of the array */</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..</span>len]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>       <span class="co">/* From 3 to 5-1 (4) */</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..</span><span class="dv">5</span>]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>         <span class="co">/* From 3 to 5-1 (4) */</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>a[<span class="dv">3</span><span class="op">..=</span><span class="dv">4</span>]<span class="op">,</span>[<span class="dv">4</span><span class="op">,</span><span class="dv">5</span>])<span class="op">;</span>        <span class="co">/* From 3 to 4 */</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(return_array_slice(<span class="op">&amp;</span>a)<span class="op">,</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the input is a fixed-size array but the output is a
size-independent slice.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> return_array_slice(a <span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span> <span class="op">;</span> <span class="dv">5</span>]) <span class="op">-&gt;</span> <span class="op">&amp;</span>[<span class="dt">u8</span>] <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>a[<span class="dv">0</span><span class="op">..</span><span class="dv">3</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="string-slices">String slices</h3>
<p>There isnâ€™t nothing special about string slices, except that the
string slice type is <code>&amp;str</code> rather than
<code>&amp;String</code></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_slice_string() <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Index              0123456789 */</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*                              10 */</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> len <span class="op">=</span> s<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(len<span class="op">,</span> <span class="dv">11</span>)<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span>len]<span class="op">,</span><span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span>]<span class="op">,</span><span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="op">..</span>len]<span class="op">,</span><span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="op">..</span><span class="dv">5</span>]<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>]<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..=</span><span class="dv">4</span>]<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..</span>]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..</span>len]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..</span><span class="dv">11</span>]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>s[<span class="dv">6</span><span class="op">..=</span><span class="dv">10</span>]<span class="op">,</span><span class="st">&quot;world&quot;</span>)<span class="op">;</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(return_string_slice(<span class="op">&amp;</span>s)<span class="op">,</span><span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the slice for a string is <code>&amp;str</code> rather than
<code>&amp;String</code></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> return_string_slice(s <span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="variables">Variables</h1>
<h2 id="constants">Constants</h2>
<p>Constants are inlined whenever they are evaluated rather than being
stored in a single memory location.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> MILLENNIUM_BUG <span class="op">:</span> <span class="dt">u16</span> <span class="op">=</span> <span class="dv">2000</span><span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_constants() <span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(MILLENNIUM_BUG<span class="op">,</span> <span class="dv">2000</span>)<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="immutable-and-mutable-variables">Immutable and Mutable
Variables</h2>
<p>Variables are declared using the <code>let</code> keyword and are
immutable by default unless the <code>mut</code> modifier is
included.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_variables() <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _a <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">9</span><span class="op">;</span>       <span class="co">/* Immutable by default */</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* _a += 1; won&#39;t compile, variable is immutable */</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> b <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">9</span><span class="op">;</span>    <span class="co">/* Made mutable by adding &#39;mut&#39; */</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    b <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(b<span class="op">,</span> <span class="dv">10</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="static-variables">Static variables</h2>
<p>Static variables are stored in a fixed memory location and referenced
accordingly whenever evaluated.</p>
<p>Letâ€™s first declare two static variables, one mutable and the other
one immutableâ€¦</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> BEST_COMMODORE_COMPUTER <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">64</span><span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Unsafe; avoid this if possible */</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> <span class="kw">mut</span> INITIAL_TEMPERATURE <span class="op">:</span> <span class="dt">i8</span> <span class="op">=</span> <span class="op">-</span><span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>First, we see that they are in scope from within a test function.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_static_variables() <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(BEST_COMMODORE_COMPUTER<span class="op">,</span> <span class="dv">64</span>)<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Don&#39;t do this! Use Mutex or similar to be safe */</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        INITIAL_TEMPERATURE <span class="op">+=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(INITIAL_TEMPERATURE<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can also prove that <code>BEST_COMMODORE_COMPUTER</code> is stored
in the same memory location.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_static_variables_reference() <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pointer_1 <span class="op">=</span> <span class="pp">std::ptr::addr_of!</span>(BEST_COMMODORE_COMPUTER)<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pointer_2 <span class="op">=</span> <span class="pp">std::ptr::addr_of!</span>(BEST_COMMODORE_COMPUTER)<span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(pointer_1<span class="op">,</span>pointer_2)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="variable-scope">Variable Scope</h2>
<p>As in most C-like languages, curly braces introduce a new scope.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_variable_scope_1() <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* This is a different x */</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* This is the original x */</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike, say, pure functional languages, variable names may be reused
within the same scope. Please note that it is the variable name that is
being reused, rather than the type it can accommodate.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_variable_scope_2() <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> asterisks <span class="op">=</span> [<span class="ch">&#39;*&#39;</span><span class="op">;</span><span class="dv">5</span>]<span class="op">;</span>         <span class="co">/* Here asterisks is an array */</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> asterisks <span class="op">=</span> asterisks<span class="op">.</span>len()<span class="op">;</span> <span class="co">/* Here asterisks is an integer */</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(asterisks<span class="op">,</span><span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="structs">Structs</h1>
<h2 id="struct-definition">Struct Definition</h2>
<p>Structs consists of one or more components using the
<code>attribute : type</code> notation. The last component may or may
not include a comma.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Spaceship <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    shield<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    fuel<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span> <span class="co">/* Comma is optional */</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="regular-struct-construction-and-query">Regular Struct
Construction and Query</h2>
<p>Structs are constructed using the same <code>attribute : value</code>
notation. The last component may or may not include a comma. Components
may be queried using the <code>struct_value.component_name</code>
notation.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_struct() <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> spaceship <span class="op">=</span> Spaceship <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        shield<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        name<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Rocinante&quot;</span>)<span class="op">,</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        fuel <span class="op">:</span> <span class="dv">12</span><span class="op">,</span> <span class="co">/* Comma is optional */</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>shield<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Rocinante&quot;</span>)<span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>fuel<span class="op">,</span> <span class="dv">12</span>)<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="name-matching-struct-construction">Name-matching Struct
Construction</h2>
<p>If the variable names match the structâ€™s component names, thereâ€™s no
need to specify each component.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_struct_name() <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> shield <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> name <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Rocinante&quot;</span>)<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fuel <span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> spaceship <span class="op">=</span> Spaceship <span class="op">{</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        shield<span class="op">,</span> <span class="co">/* has to match struct&#39;s attribute name exactly */</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        name<span class="op">,</span>   <span class="co">/* has to match struct&#39;s attribute name exactly */</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        fuel    <span class="co">/* has to match struct&#39;s attribute name exactly */</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>shield<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Rocinante&quot;</span>)<span class="op">;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>fuel<span class="op">,</span> <span class="dv">12</span>)<span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="updating-mutable-struct">Updating Mutable Struct</h2>
<p>In this case, each attribute must be updated separately</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_struct_update_mutable() <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> spaceship <span class="op">=</span> Spaceship <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        shield<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        name<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Rocinante&quot;</span>)<span class="op">,</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        fuel <span class="op">:</span> <span class="dv">12</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Rocinante&quot;</span>)<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    spaceship<span class="op">.</span>name <span class="op">=</span>  <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;The Anubis&quot;</span>)<span class="op">;</span> <span class="co">/* Update here! */</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;The Anubis&quot;</span>)<span class="op">;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>    </span></code></pre></div>
<h2 id="updating-immutable-struct">Updating Immutable Struct</h2>
<p>This essentially involves creating a new struct value based on the
value from an existing one, specifying it as the last component using
the <code>..base_struct</code> notation.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_struct_update_immutable() <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> spaceship1 <span class="op">=</span> Spaceship <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        shield<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        name<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Rocinante&quot;</span>)<span class="op">,</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        fuel <span class="op">:</span> <span class="dv">12</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> spaceship2 <span class="op">=</span> Spaceship <span class="op">{</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        name<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;The Anubis&quot;</span>)<span class="op">,</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">..</span>spaceship1 <span class="co">/* Note the reference to the previous struct here */</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship1<span class="op">.</span>shield<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship1<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Rocinante&quot;</span>)<span class="op">;</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship1<span class="op">.</span>fuel<span class="op">,</span> <span class="dv">12</span>)<span class="op">;</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship2<span class="op">.</span>shield<span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship2<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;The Anubis&quot;</span>)<span class="op">;</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(spaceship2<span class="op">.</span>fuel<span class="op">,</span> <span class="dv">12</span>)<span class="op">;</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="composite-structs">Composite Structs</h2>
<p>A struct may be made up of other structs</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SpacePort <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    name <span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    docked_spaceship<span class="op">:</span> Spaceship<span class="op">,</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can refer to the nested components using the dot notation.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_struct_composite_struct() <span class="op">{</span>   </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> space_port <span class="op">=</span> SpacePort <span class="op">{</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        name <span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Lovell City&quot;</span>)<span class="op">,</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        docked_spaceship <span class="op">:</span> Spaceship <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            shield<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>            name<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Rocinante&quot;</span>)<span class="op">,</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>            fuel <span class="op">:</span> <span class="dv">12</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(space_port<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Lovell City&quot;</span>)<span class="op">;</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(space_port<span class="op">.</span>docked_spaceship<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Rocinante&quot;</span>)<span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span></code></pre></div>
<h2 id="tuple-struct">Tuple Struct</h2>
<p>In a tuple struct, components are positional rather than having a
name.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> RGB(<span class="dt">u8</span><span class="op">,</span><span class="dt">u8</span><span class="op">,</span><span class="dt">u8</span>)<span class="op">;</span> <span class="co">/* Declaration */</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_tuple_struct() <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> purple <span class="op">=</span> RGB(<span class="dv">255</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">255</span>)<span class="op">;</span> <span class="co">/* Construction */</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(purple<span class="op">.</span><span class="dv">0</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span>   <span class="co">/* Component 0 Query */</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(purple<span class="op">.</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span>     <span class="co">/* Component 1 Query */</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(purple<span class="op">.</span><span class="dv">2</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span>   <span class="co">/* Component 2 Query */</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(purple<span class="op">,</span> RGB(<span class="dv">255</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">255</span>))<span class="op">;</span> <span class="co">/* via PartialEq and Debug */</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="unit-like-struct">Unit-Like Struct</h2>
<p>This struct has no components.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> NoComponents<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_unit_struct() <span class="op">{</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> no_components <span class="op">=</span> NoComponents<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(no_components<span class="op">,</span> NoComponents)<span class="op">;</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="control-flow">Control Flow</h1>
<p>Similarly to Go, Rust does not require boolean expressions in control
flow statements to be flanked by parentheses.</p>
<h2 id="if-statements">If Statements</h2>
<p>If statements are implemented using
<code>if boolean_expression {...}</code>.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_if() <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="dv">3</span> <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;b&#39;</span><span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="ch">&#39;b&#39;</span>)<span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If-Else statements are implemented using
<code>if boolean_expression {...} else {...}</code>.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_if_else() <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r<span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">3</span> <span class="op">{</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;b&#39;</span><span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="ch">&#39;b&#39;</span>)<span class="op">;</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If-The-Else statements are implemented using
<code>if boolean_expression {...} else if boolean_expression {...} else {...}</code>.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_if_then_else() <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">3</span> <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">5</span> <span class="op">{</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;b&#39;</span><span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;c&#39;</span><span class="op">;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="ch">&#39;x&#39;</span><span class="op">;</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>     <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="ch">&#39;c&#39;</span>)<span class="op">;</span>  </span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="if-expressions">If Expressions</h2>
<p>It is idiomatic in Rust to use <code>if/else</code> to formulate
expressions rather than for imperative control flow purposes.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_if_expressions() <span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="cf">if</span> <span class="dv">3</span> <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">{</span> <span class="cn">true</span> <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="cn">false</span> <span class="op">},</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="infinite-loop-statements">Infinite Loop Statements</h2>
<p>Infinite loops may be implemented using <code>loop {...}</code> and
exited using <code>break;</code>.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_loop_1() <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&gt;=</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">128</span>)<span class="op">;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="infinite-loop-expressions">Infinite Loop Expressions</h2>
<p>Infinite loops may also be used to formulate expressions using the
<code>let variable = loop { break return_value };</code> syntax</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_return_value_from_loop() <span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r <span class="op">=</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&gt;=</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span> x<span class="op">;</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">128</span>)<span class="op">;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span> <span class="dv">128</span>)<span class="op">;</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Nested loops may be exited using labels. Labels are prefixed with an
apostrophe as follows: <code>'label</code>:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_loop_with_labels() <span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> results <span class="op">=</span> [<span class="dv">0</span><span class="op">;</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">&#39;top_loop</span> <span class="op">:</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&#39;inner_loop</span> <span class="op">:</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>            results[index] <span class="op">+=</span> (<span class="dv">2</span> <span class="op">+</span> index) <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> results[index] <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> <span class="ot">&#39;inner_loop</span><span class="op">;</span> <span class="co">/* implied */</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="op">&gt;=</span><span class="dv">3</span> <span class="op">{</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span> <span class="ot">&#39;top_loop</span><span class="op">;</span> <span class="co">/* implied */</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(results[<span class="dv">0</span>]<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(results[<span class="dv">1</span>]<span class="op">,</span> <span class="dv">12</span>)<span class="op">;</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(results[<span class="dv">2</span>]<span class="op">,</span> <span class="dv">8</span>)<span class="op">;</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="while-loop">While Loop</h2>
<p>While loops are implemented using the
<code>while boolean_expression {...}</code> syntax.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_while() <span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> x <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="for-loop">For Loop</h2>
<p>The default, simplest <em>for loop</em> iterates over a sequence of
elements. In concrete, it can iterate over iterable types, such as
ranges, collections (e.g., arrays, vectors, slices), iterators, etc. It
is implemented using the <code>for element in sequence {...}</code>
syntax.</p>
<p>In this example, it iterates over an array:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_for() <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> numbers <span class="op">{</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r <span class="op">+</span> value<span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="for-loop-range">For Loop (Range)</h2>
<p>For loops can also be used to iterate over a custom <em>range</em>
using the <code>for value in start_number..end_number+1 {}</code>
syntax.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_for_just_index() <span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>numbers<span class="op">.</span>len() <span class="op">{</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r <span class="op">+</span> <span class="op">&amp;</span>numbers[index]<span class="op">;</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In most cases, it is more practical to declare the range as in
<code>start_number..=end_number</code> (note the <code>=</code>
sign)</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_for_range() <span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span><span class="dv">3</span> <span class="op">{</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r <span class="op">+</span> value<span class="op">;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It is also possible to define a custom step value via the
<code>step_by(number)</code> method.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_for_range_step() <span class="op">{</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> (<span class="dv">1</span><span class="op">..=</span><span class="dv">8</span>)<span class="op">.</span>step_by(<span class="dv">2</span>) <span class="op">{</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r <span class="op">+</span> value<span class="op">;</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="dv">16</span>)<span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="for-loop-over-index">For Loop over Index</h2>
<p>Similarly to Python, it is possible to iterate both through the
sequenceâ€™s values and each elementâ€™s ordinal index, at the same
time.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_for_index_and_value() <span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (index<span class="op">,</span> value) <span class="kw">in</span> numbers<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r <span class="op">+</span> value<span class="op">;</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(value<span class="op">,</span> <span class="op">&amp;</span>numbers[index])<span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(r<span class="op">,</span><span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</body>
</html>
